"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageShorter = void 0;
const builders_1 = require("../../builders");
const structures_1 = require("../../structures");
const cache_1 = require("../../cache");
const client_1 = require("../../client");
const base_1 = require("./base");
class MessageShorter extends base_1.BaseShorter {
    async write(channelId, { files, ...body }) {
        const parsedFiles = files ? await (0, builders_1.resolveFiles)(files) : undefined;
        const transformedBody = structures_1.MessagesMethods.transformMessageBody(body, parsedFiles, this.client);
        return this.client.proxy
            .channels(channelId)
            .messages.post({
            body: transformedBody,
            files: parsedFiles,
        })
            .then(async (message) => {
            await this.client.cache.messages?.setIfNI(cache_1.CacheFrom.Rest, 'GuildMessages', message.id, message.channel_id, message);
            return client_1.Transformers.Message(this.client, message);
        });
    }
    async edit(messageId, channelId, { files, ...body }) {
        const parsedFiles = files ? await (0, builders_1.resolveFiles)(files) : undefined;
        return this.client.proxy
            .channels(channelId)
            .messages(messageId)
            .patch({
            body: structures_1.MessagesMethods.transformMessageBody(body, parsedFiles, this.client),
            files: parsedFiles,
        })
            .then(async (message) => {
            await this.client.cache.messages?.setIfNI(cache_1.CacheFrom.Rest, 'GuildMessages', message.id, message.channel_id, message);
            return client_1.Transformers.Message(this.client, message);
        });
    }
    crosspost(messageId, channelId, reason) {
        return this.client.proxy
            .channels(channelId)
            .messages(messageId)
            .crosspost.post({ reason })
            .then(async (m) => {
            await this.client.cache.messages?.setIfNI(cache_1.CacheFrom.Rest, 'GuildMessages', m.id, m.channel_id, m);
            return client_1.Transformers.Message(this.client, m);
        });
    }
    delete(messageId, channelId, reason) {
        return this.client.proxy
            .channels(channelId)
            .messages(messageId)
            .delete({ reason })
            .then(async () => {
            await this.client.cache.messages?.removeIfNI('GuildMessages', messageId, channelId);
            this.client.components.deleteValue(messageId, 'messageDelete');
        });
    }
    async fetch(messageId, channelId, force = false) {
        if (!force) {
            const message = await this.client.cache.messages?.get(messageId);
            if (message)
                return message;
        }
        return this.client.proxy
            .channels(channelId)
            .messages(messageId)
            .get()
            .then(async (x) => {
            await this.client.cache.messages?.set(cache_1.CacheFrom.Rest, x.id, x.channel_id, x);
            return client_1.Transformers.Message(this.client, x);
        });
    }
    purge(messages, channelId, reason) {
        return this.client.proxy
            .channels(channelId)
            .messages['bulk-delete'].post({ body: { messages }, reason })
            .then(() => this.client.cache.messages?.removeIfNI('GuildMessages', messages, channelId));
    }
    thread(channelId, messageId, options) {
        return this.client.threads.fromMessage(channelId, messageId, options);
    }
    endPoll(channelId, messageId) {
        return this.client.proxy
            .channels(channelId)
            .polls(messageId)
            .expire.post()
            .then(message => client_1.Transformers.Message(this.client, message));
    }
    getAnswerVoters(channelId, messageId, answerId) {
        return this.client.proxy
            .channels(channelId)
            .polls(messageId)
            .answers(answerId)
            .get()
            .then(data => data.users.map(user => client_1.Transformers.User(this.client, user)));
    }
    list(channelId, fetchOptions) {
        return this.client.proxy
            .channels(channelId)
            .messages.get({ query: fetchOptions })
            .then(messages => messages.map(message => client_1.Transformers.Message(this.client, message)));
    }
}
exports.MessageShorter = MessageShorter;
