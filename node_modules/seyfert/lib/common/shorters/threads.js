"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreadShorter = void 0;
const __1 = require("../..");
const structures_1 = require("../../structures");
const base_1 = require("./base");
class ThreadShorter extends base_1.BaseShorter {
    /**
     * Creates a new thread in the channel (only guild based channels).
     * @param channelId The ID of the parent channel.
     * @param reason The reason for unpinning the message.
     * @returns A promise that resolves when the thread is succesfully created.
     */
    create(channelId, body, reason) {
        return (this.client.proxy
            .channels(channelId)
            .threads.post({ body, reason })
            // When testing this, discord returns the thread object, but in discord api types it does not.
            .then(async (thread) => {
            await this.client.cache.channels?.setIfNI(__1.CacheFrom.Rest, 'Guilds', thread.id, thread.guild_id, thread);
            return (0, structures_1.channelFrom)(thread, this.client);
        }));
    }
    fromMessage(channelId, messageId, options) {
        const { reason, ...body } = options;
        return this.client.proxy
            .channels(channelId)
            .messages(messageId)
            .threads.post({ body, reason })
            .then(async (thread) => {
            await this.client.cache.channels?.setIfNI(__1.CacheFrom.Rest, 'Guilds', thread.id, thread.guild_id, thread);
            return (0, structures_1.channelFrom)(thread, this.client);
        });
    }
    join(threadId) {
        return this.client.proxy.channels(threadId)['thread-members']('@me').put();
    }
    leave(threadId) {
        return this.client.proxy.channels(threadId)['thread-members']('@me').delete();
    }
    lock(threadId, locked = true, reason) {
        return this.edit(threadId, { locked }, reason).then(x => (0, structures_1.channelFrom)(x, this.client));
    }
    async edit(threadId, body, reason) {
        return (await this.client.channels.edit(threadId, body, { reason }));
    }
    removeMember(threadId, memberId) {
        return this.client.proxy.channels(threadId)['thread-members'](memberId).delete();
    }
    fetchMember(threadId, memberId, with_member) {
        return this.client.proxy.channels(threadId)['thread-members'](memberId).get({
            query: {
                with_member,
            },
        });
    }
    addMember(threadId, memberId) {
        return this.client.proxy.channels(threadId)['thread-members'](memberId).put();
    }
    listMembers(threadId, query) {
        return this.client.proxy.channels(threadId)['thread-members'].get({ query });
    }
    async listArchivedThreads(channelId, type, query) {
        const data = await this.client.proxy.channels(channelId).threads.archived[type].get({ query });
        return {
            threads: data.threads.map(thread => (0, structures_1.channelFrom)(thread, this.client)),
            members: data.members,
            hasMore: data.has_more,
        };
    }
    async listJoinedArchivedPrivate(channelId, query) {
        const data = await this.client.proxy.channels(channelId).users('@me').threads.archived.private.get({ query });
        return {
            threads: data.threads.map(thread => (0, structures_1.channelFrom)(thread, this.client)),
            members: data.members,
            hasMore: data.has_more,
        };
    }
}
exports.ThreadShorter = ThreadShorter;
