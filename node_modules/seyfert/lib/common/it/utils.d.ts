import { type ColorResolvable, type EmojiResolvable, type Logger, type ObjectToLower, type ObjectToSnake, type TypeArray } from '..';
import type { Cache } from '../../cache';
import { type APIPartialEmoji, GatewayIntentBits } from '../../types';
/**
 * Calculates the shard ID for a guild based on its ID.
 * @param guildId The ID of the guild.
 * @param shards The number of shards to calculate the ID for.
 * @returns The shard ID.
 */
export declare function calculateShardId(guildId: string, shards?: number): number;
/**
 * Resolves the color to a numeric representation.
 * @param color The color to resolve.
 * @returns The numeric representation of the color.
 */
export declare function resolveColor(color: ColorResolvable): number;
/**
 * Delays the resolution of a Promise by the specified time.
 * @param time The time in milliseconds to delay the resolution.
 * @param result The value to resolve with after the delay.
 * @returns A Promise that resolves after the specified time with the provided result.
 */
export declare function delay<T>(time: number, result?: T): Promise<T>;
/**
 * Checks if a given value is an object.
 * @param o The value to check.
 * @returns `true` if the value is an object, otherwise `false`.
 */
export declare function isObject(o: any): o is Record<string, unknown>;
/**
 * Merges multiple options objects together, deeply extending objects.
 * @param defaults The default options object.
 * @param options Additional options objects to merge.
 * @returns The merged options object.
 */
export declare function MergeOptions<T>(defaults: any, ...options: any[]): T;
/**
 * Splits an array into two arrays based on the result of a predicate function.
 * @param arr The array to split.
 * @param func The predicate function used to test elements of the array.
 * @returns An object containing two arrays: one with elements that passed the test and one with elements that did not.
 */
export declare function filterSplit<Element, Never = Element>(arr: (Element | Never)[], func: (value: Element | Never) => boolean): {
    expect: Element[];
    never: Never[];
};
/**
 * Represents a base handler class.
 */
export declare class BaseHandler {
    protected logger: Logger;
    /**
     * Initializes a new instance of the BaseHandler class.
     * @param logger The logger instance.
     */
    constructor(logger: Logger);
    /**
     * Filters a file path.
     * @param path The path to filter.
     * @returns `true` if the path passes the filter, otherwise `false`.
     */
    filter: (path: string) => boolean;
    /**
     * Recursively retrieves all files in a directory.
     * @param dir The directory path.
     * @returns A Promise that resolves to an array of file paths.
     */
    protected getFiles(dir: string): Promise<string[]>;
    /**
     * Loads files from given paths.
     * @param paths The paths of the files to load.
     * @returns A Promise that resolves to an array of loaded files.
     */
    protected loadFiles<T extends NonNullable<unknown>>(paths: string[]): Promise<T[]>;
    /**
     * Loads files from given paths along with additional information.
     * @param paths The paths of the files to load.
     * @returns A Promise that resolves to an array of objects containing name, file, and path.
     */
    protected loadFilesK<T>(paths: string[]): Promise<{
        name: string;
        file: T;
        path: string;
    }[]>;
}
/**
 * Convert a camelCase object to snake_case.
 * @param target The object to convert.
 * @returns The converted object.
 */
export declare function toSnakeCase<Obj extends Record<string, any>>(target: Obj): ObjectToSnake<Obj>;
/**
 * Convert a snake_case object to camelCase.
 * @param target The object to convert.
 * @returns The converted object.
 */
export declare function toCamelCase<Obj extends Record<string, any>>(target: Obj): ObjectToLower<Obj>;
export declare const ReplaceRegex: {
    camel: (s: string) => string;
    snake: (s: string) => string;
};
export declare function magicImport(path: string): Promise<any>;
export type OnFailCallback = (error: unknown) => any;
export declare function fakePromise<T = unknown | Promise<unknown>>(value: T): {
    then<R>(callback: (arg: Awaited<T>) => R): R;
};
export declare function lazyLoadPackage<T>(mod: string): T | undefined;
export declare function isCloudfareWorker(): boolean;
/**
 *
 * Convert a timestamp to a snowflake.
 * @param id The timestamp to convert.
 * @returns The snowflake.
 */
export declare function snowflakeToTimestamp(id: string): bigint;
export declare function resolvePartialEmoji(emoji: EmojiResolvable): APIPartialEmoji | undefined;
export declare function resolveEmoji(emoji: EmojiResolvable, cache: Cache): Promise<APIPartialEmoji | undefined>;
export declare function encodeEmoji(rawEmoji: APIPartialEmoji): string;
export declare function hasProps<T extends Record<any, any>>(target: T, props: TypeArray<keyof T>): boolean;
export declare function hasIntent(intents: number, target: keyof typeof GatewayIntentBits | GatewayIntentBits): boolean;
export declare function toArrayBuffer(buffer: Buffer): ArrayBuffer;
export declare function toBuffer(arrayBuffer: ArrayBuffer): Buffer<ArrayBuffer>;
export declare function assertString(value: unknown, message?: string): asserts value is string;
