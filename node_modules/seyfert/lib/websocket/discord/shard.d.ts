import { Logger, type MakeRequired } from '../../common';
import { type APIGuildMember, type GatewayGuildMembersChunkPresence, type GatewayReceivePayload, type GatewaySendPayload } from '../../types';
import type { GatewayRequestGuildMembersDataWithQuery, GatewayRequestGuildMembersDataWithUserIds } from '../../types/gateway';
import { DynamicBucket } from '../structures';
import { ConnectTimeout } from '../structures/timeout';
import { BaseSocket } from './basesocket';
import type { ShardData, ShardOptions } from './shared';
import { ShardSocketCloseCodes } from './shared';
export interface ShardHeart {
    interval: number;
    nodeInterval?: NodeJS.Timeout;
    lastAck?: number;
    lastBeat?: number;
    ack: boolean;
}
export declare class Shard {
    id: number;
    logger: Logger;
    debugger?: Logger;
    data: Partial<ShardData> | ShardData;
    websocket: BaseSocket | null;
    connectTimeout: ConnectTimeout;
    heart: ShardHeart;
    bucket: DynamicBucket;
    offlineSendQueue: ((_?: unknown) => void)[];
    pendingGuilds: Set<string>;
    options: MakeRequired<ShardOptions, 'properties' | 'ratelimitOptions' | 'reconnectTimeout' | 'connectionTimeout'>;
    isReady: boolean;
    connectionTimeout?: NodeJS.Timeout;
    private requestGuildMembersChunk;
    constructor(id: number, options: ShardOptions);
    get latency(): number;
    get isOpen(): boolean;
    get gatewayURL(): string;
    get resumeGatewayURL(): string | undefined;
    get currentGatewayURL(): string;
    ping(): Promise<number>;
    connect(): Promise<void>;
    send<T extends GatewaySendPayload = GatewaySendPayload>(force: boolean, message: T): Promise<void>;
    identify(): Promise<void>;
    get resumable(): boolean;
    resume(): Promise<void>;
    heartbeat(requested: boolean): void;
    disconnect(code?: ShardSocketCloseCodes): void;
    reconnect(code?: ShardSocketCloseCodes): Promise<void>;
    onpacket(packet: GatewayReceivePayload): void | Promise<void>;
    requestGuildMember(options: Omit<GatewayRequestGuildMembersDataWithQuery, 'nonce'> | Omit<GatewayRequestGuildMembersDataWithUserIds, 'nonce'>): Promise<{
        members: APIGuildMember[];
        presences: GatewayGuildMembersChunkPresence[];
    }>;
    protected handleClosed(close: {
        code: number;
        reason: string;
    }): Promise<void>;
    close(code: number, reason: string): void;
    protected handleMessage(data: string | Buffer): void | Promise<void>;
    checkOffline(force: boolean): Promise<unknown>;
    calculateSafeRequests(): number;
}
