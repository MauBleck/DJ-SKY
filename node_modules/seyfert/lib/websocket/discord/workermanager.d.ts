import { type Worker as ClusterWorker } from 'node:cluster';
import type { Worker as WorkerThreadsWorker } from 'node:worker_threads';
import { ApiHandler, type CustomWorkerManagerEvents, Logger, type UsingClient, type WorkerClient } from '../..';
import { type Adapter } from '../../cache';
import { type Identify, type PickPartial } from '../../common';
import type { GatewayPresenceUpdateData, GatewaySendPayload } from '../../types';
import { ConnectQueue } from '../structures/timeout';
import type { ShardOptions, WorkerData, WorkerManagerOptions } from './shared';
import type { WorkerInfo, WorkerMessages, WorkerShardInfo } from './worker';
export declare class WorkerManager extends Map<number, (ClusterWorker | WorkerThreadsWorker | {
    ready?: boolean;
}) & {
    ready?: boolean;
    disconnected?: boolean;
    resharded?: boolean;
}> {
    static prepareSpaces(options: {
        shardStart: number;
        shardEnd: number;
        shardsPerWorker: number;
    }, logger?: Logger): number[][];
    options: PickPartial<Required<WorkerManagerOptions>, 'adapter' | 'handleWorkerMessage' | 'handlePayload' | 'getRC'>;
    debugger?: Logger;
    connectQueue: ConnectQueue;
    workerQueue: (() => void)[];
    cacheAdapter: Adapter;
    promises: Map<string, {
        resolve: (value: any) => void;
        timeout: NodeJS.Timeout;
    }>;
    rest: ApiHandler;
    reshardingWorkerQueue: (() => void)[];
    private _info?;
    constructor(options: Omit<PickPartial<WorkerManagerOptions, 'token' | 'intents' | 'info' | 'handlePayload' | 'handleWorkerMessage'>, 'resharding'> & {
        resharding?: PickPartial<NonNullable<WorkerManagerOptions['resharding']>, 'getInfo'>;
    });
    setCache(adapter: Adapter): void;
    setRest(rest: ApiHandler): void;
    get remaining(): number;
    get concurrency(): number;
    get totalWorkers(): number;
    get totalShards(): number;
    get shardStart(): number;
    get shardEnd(): number;
    get shardsPerWorker(): number;
    syncLatency({ shardId, workerId, }: {
        shardId: number;
        workerId?: number;
    } | {
        shardId?: number;
        workerId: number;
    }): Promise<number>;
    calculateShardId(guildId: string): number;
    calculateWorkerId(shardId: number): number;
    postMessage(id: number, body: ManagerMessages): void;
    prepareWorkers(shards: number[][], resharding?: boolean): void;
    createWorker(workerData: WorkerData): ClusterWorker | WorkerThreadsWorker | ({
        ready?: boolean;
    } & {
        ready?: boolean;
        disconnected?: boolean;
        resharded?: boolean;
    });
    spawn(workerId: number, shardId: number, resharding?: boolean): void;
    handleWorkerMessage(message: WorkerMessages): Promise<void>;
    private generateNonce;
    private generateSendPromise;
    send(data: GatewaySendPayload, shardId: number): Promise<true>;
    getShardInfo(shardId: number): Promise<WorkerShardInfo>;
    getWorkerInfo(workerId: number): Promise<WorkerInfo>;
    tellWorker<R, V extends Record<string, unknown>>(workerId: number, func: (_: WorkerClient & UsingClient, vars: V) => R, vars: V): Promise<R>;
    tellWorkers<R, V extends Record<string, unknown>>(func: (_: WorkerClient & UsingClient, vars: V) => R, vars: V): Promise<Awaited<R>[]>;
    start(): Promise<void>;
    startResharding(): Promise<void>;
}
type CreateManagerMessage<T extends string, D extends object = object> = {
    type: T;
} & D;
export type ManagerAllowConnect = CreateManagerMessage<'ALLOW_CONNECT', {
    shardId: number;
    presence: GatewayPresenceUpdateData;
}>;
export type ManagerAllowConnectResharding = CreateManagerMessage<'ALLOW_CONNECT_RESHARDING', {
    shardId: number;
    presence: GatewayPresenceUpdateData;
}>;
export type ManagerWorkerAlreadyExistsResharding = CreateManagerMessage<'WORKER_ALREADY_EXISTS_RESHARDING'>;
export type ManagerSpawnShards = CreateManagerMessage<'SPAWN_SHARDS', Pick<ShardOptions, 'info' | 'properties' | 'compress'>>;
export type ManagerSpawnShardsResharding = CreateManagerMessage<'SPAWN_SHARDS_RESHARDING', Pick<ShardOptions, 'info' | 'properties' | 'compress'>>;
export type DisconnectAllShardsResharding = CreateManagerMessage<'DISCONNECT_ALL_SHARDS_RESHARDING'>;
export type ConnnectAllShardsResharding = CreateManagerMessage<'CONNECT_ALL_SHARDS_RESHARDING'>;
export type ManagerSendPayload = CreateManagerMessage<'SEND_PAYLOAD', GatewaySendPayload & {
    shardId: number;
    nonce: string;
}>;
export type ManagerRequestShardInfo = CreateManagerMessage<'SHARD_INFO', {
    nonce: string;
    shardId: number;
}>;
export type ManagerRequestWorkerInfo = CreateManagerMessage<'WORKER_INFO', {
    nonce: string;
}>;
export type ManagerSendCacheResult = CreateManagerMessage<'CACHE_RESULT', {
    nonce: string;
    result: any;
}>;
export type ManagerSendBotReady = CreateManagerMessage<'BOT_READY'>;
export type ManagerSendApiResponse = CreateManagerMessage<'API_RESPONSE', {
    response: any;
    error?: any;
    nonce: string;
}>;
export type ManagerExecuteEvalToWorker = CreateManagerMessage<'EXECUTE_EVAL_TO_WORKER', {
    func: string;
    nonce: string;
    vars: string;
    toWorkerId: number;
}>;
export type ManagerExecuteEval = CreateManagerMessage<'EXECUTE_EVAL', {
    func: string;
    vars: string;
    nonce: string;
}>;
export type ManagerSendEvalResponse = CreateManagerMessage<'EVAL_RESPONSE', {
    response: any;
    nonce: string;
}>;
export type BaseManagerMessages = ManagerAllowConnect | ManagerSpawnShards | ManagerSendPayload | ManagerRequestShardInfo | ManagerRequestWorkerInfo | ManagerSendCacheResult | ManagerSendBotReady | ManagerSendApiResponse | ManagerSendEvalResponse | ManagerExecuteEvalToWorker | ManagerWorkerAlreadyExistsResharding | ManagerSpawnShardsResharding | ManagerAllowConnectResharding | DisconnectAllShardsResharding | ConnnectAllShardsResharding | ManagerExecuteEval;
export type CustomManagerMessages = {
    [K in keyof CustomWorkerManagerEvents]: Identify<{
        type: K;
    } & Identify<CustomWorkerManagerEvents[K] extends never ? {} : CustomWorkerManagerEvents[K]>>;
};
export type ManagerMessages = {
    [K in BaseManagerMessages['type']]: Identify<Extract<BaseManagerMessages, {
        type: K;
    }>>;
}[BaseManagerMessages['type']] | CustomManagerMessages[keyof CustomManagerMessages];
export {};
