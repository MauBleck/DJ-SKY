import { Logger, type MakeRequired } from '../../common';
import type { MakeDeepPartial } from '../../common/types/util';
import { type GatewaySendPayload, type GatewayUpdatePresence, type GatewayVoiceStateUpdate } from '../../types';
import { ShardManagerDefaults } from '../constants';
import { ConnectQueue } from '../structures/timeout';
import { Shard } from './shard';
import { type ShardData, type ShardManagerOptions, ShardSocketCloseCodes } from './shared';
export declare class ShardManager extends Map<number, Shard> {
    connectQueue: ConnectQueue;
    options: MakeRequired<ShardManagerOptions, keyof typeof ShardManagerDefaults>;
    debugger?: Logger;
    constructor(options: MakeDeepPartial<ShardManagerOptions, 'resharding'>);
    get totalShards(): number;
    get shardStart(): number;
    get shardEnd(): number;
    get remaining(): number;
    get concurrency(): number;
    get latency(): number;
    calculateShardId(guildId: string): number;
    create(shardId: number): Shard;
    spawnShards(): Promise<void>;
    startResharder(): Promise<void>;
    spawnBuckets(): Shard[][];
    forceIdentify(shardId: number): Promise<void>;
    disconnect(shardId: number, code?: ShardSocketCloseCodes): void | undefined;
    disconnectAll(code?: ShardSocketCloseCodes): void;
    setShardPresence(shardId: number, payload: GatewayUpdatePresence['d']): void;
    setPresence(payload: GatewayUpdatePresence['d']): void;
    joinVoice(guild_id: string, channel_id: string, options: Pick<GatewayVoiceStateUpdate['d'], 'self_deaf' | 'self_mute'>): void;
    leaveVoice(guild_id: string): void;
    send<T extends GatewaySendPayload>(shardId: number, payload: T): void;
    resume(shardId: number, shardData: MakeRequired<ShardData>): unknown;
}
