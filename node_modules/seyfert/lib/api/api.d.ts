import { type UUID } from 'node:crypto';
import { type Awaitable, Logger } from '../common';
import type { WorkerSendApiRequest } from '../websocket/discord/worker';
import type { APIRoutes } from './Routes';
import { Bucket } from './bucket';
import { type ApiHandlerInternalOptions, type ApiHandlerOptions, type ApiRequestOptions, type HttpMethods, type RawFile, type RequestHeaders } from './shared';
export interface ApiHandler {
    debugger?: Logger;
}
export type OnRatelimitCallback = (response: Response, request: ApiRequestOptions) => Awaitable<any>;
export declare class ApiHandler {
    options: ApiHandlerInternalOptions;
    globalBlock: boolean;
    ratelimits: Map<string, Bucket>;
    readyQueue: (() => void)[];
    cdn: import("./Routes").CDNRoute;
    workerPromises?: Map<string, {
        resolve: (value: any) => any;
        reject: (error: any) => any;
    }>;
    onRatelimit?: OnRatelimitCallback;
    constructor(options: ApiHandlerOptions);
    set debug(active: boolean);
    get proxy(): APIRoutes;
    globalUnblock(): void;
    randomUUID(): UUID;
    protected sendMessage(_body: WorkerSendApiRequest): void;
    protected postMessage<T = unknown>(body: WorkerSendApiRequest): Promise<T>;
    request<T = unknown>(method: HttpMethods, url: `/${string}`, { auth, ...request }?: ApiRequestOptions): Promise<T>;
    parseError(method: HttpMethods, route: `/${string}`, response: Response, result: string | Record<string, any>): Error;
    parseValidationError(data: Record<string, any>, path?: string, errors?: string[]): string[];
    handle50X(method: HttpMethods, url: `/${string}`, request: ApiRequestOptions, next: () => void): Promise<unknown>;
    handle429(route: string, method: HttpMethods, url: `/${string}`, request: ApiRequestOptions, response: Response, result: string, next: () => void, reject: (err: unknown) => void, now: number): Promise<unknown>;
    clearResetInterval(route: string): void;
    setResetBucket(route: string, resp: Response, now: number, headerNow: number): void;
    setRatelimitsBucket(route: string, resp: Response): void;
    parseRequest(options: {
        url: string;
        headers: RequestHeaders;
        request: ApiRequestOptions;
    }): {
        data: string | FormData | undefined;
        finalUrl: `/${string}`;
    };
    routefy(url: string, method: HttpMethods): `/${string}`;
}
export type RequestOptions = Pick<ApiRequestOptions, 'reason' | 'auth' | 'appendToFormData' | 'token'>;
export type RestArguments<B extends Record<string, any> | undefined, Q extends never | Record<string, any> = never, F extends RawFile[] = RawFile[]> = ({
    body: B;
    files?: F;
} | (Q extends never | undefined ? {} : {
    query?: Q;
})) & RequestOptions;
export type RestArgumentsNoBody<Q extends never | Record<string, any> = never> = {
    query?: Q;
    files?: RawFile[];
} & RequestOptions;
