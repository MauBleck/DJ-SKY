"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuCommandContext = void 0;
const transformers_1 = require("../../client/transformers");
const common_1 = require("../../common");
const types_1 = require("../../types");
const basecontext_1 = require("../basecontext");
class MenuCommandContext extends basecontext_1.BaseContext {
    client;
    interaction;
    shardId;
    command;
    constructor(client, interaction, shardId, command) {
        super(client);
        this.client = client;
        this.interaction = interaction;
        this.shardId = shardId;
        this.command = command;
    }
    metadata = {};
    globalMetadata = {};
    // biome-ignore lint/suspicious/useGetterReturn: default don't exist.
    get target() {
        switch (this.interaction.data.type) {
            case types_1.ApplicationCommandType.Message: {
                const data = this.interaction.data.resolved.messages[this.interaction.data.targetId];
                return transformers_1.Transformers.Message(this.client, (0, common_1.toSnakeCase)(data));
            }
            case types_1.ApplicationCommandType.User: {
                const data = this.interaction.data.resolved.users[this.interaction.data.targetId];
                return transformers_1.Transformers.User(this.client, (0, common_1.toSnakeCase)(data));
            }
        }
    }
    get t() {
        return this.client.t(this.interaction.locale ?? this.client.langs.defaultLang ?? 'en-US');
    }
    get fullCommandName() {
        return this.command.name;
    }
    write(body, withResponse) {
        return this.interaction.write(body, withResponse);
    }
    modal(body) {
        return this.interaction.modal(body);
    }
    deferReply(ephemeral = false, withResponse) {
        return this.interaction.deferReply(ephemeral ? types_1.MessageFlags.Ephemeral : undefined, withResponse);
    }
    editResponse(body) {
        return this.interaction.editResponse(body);
    }
    deleteResponse() {
        return this.interaction.deleteResponse();
    }
    editOrReply(body, withResponse) {
        return this.interaction.editOrReply(body, withResponse);
    }
    followup(body) {
        return this.interaction.followup(body);
    }
    fetchResponse() {
        return this.interaction.fetchResponse();
    }
    channel(mode = 'flow') {
        if (mode === 'cache')
            return this.client.cache.adapter.isAsync ? Promise.resolve(this.interaction.channel) : this.interaction.channel;
        return this.client.channels.fetch(this.channelId, mode === 'rest');
    }
    me(mode = 'flow') {
        if (!this.guildId)
            return mode === 'cache' ? (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined) : Promise.resolve();
        switch (mode) {
            case 'cache':
                return this.client.cache.members?.get(this.client.botId, this.guildId);
            default:
                return this.client.members.fetch(this.guildId, this.client.botId, mode === 'rest');
        }
    }
    guild(mode = 'flow', query) {
        if (!this.guildId)
            return mode === 'cache' ? (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined) : Promise.resolve();
        switch (mode) {
            case 'cache':
                return (this.client.cache.guilds?.get(this.guildId) ||
                    (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined));
            default:
                return this.client.guilds.fetch(this.guildId, { force: mode === 'rest', query });
        }
    }
    get guildId() {
        return this.interaction.guildId;
    }
    get channelId() {
        return this.interaction.channel.id;
    }
    get author() {
        return this.interaction.user;
    }
    get member() {
        return this.interaction.member;
    }
    isMenu() {
        return true;
    }
    isMenuUser() {
        return this.interaction.data.type === types_1.ApplicationCommandType.User;
    }
    isMenuMessage() {
        return this.interaction.data.type === types_1.ApplicationCommandType.Message;
    }
    inGuild() {
        return !!this.guildId;
    }
}
exports.MenuCommandContext = MenuCommandContext;
