import type { Client, WorkerClient } from '../client';
import type { UsingClient } from '../commands';
import type { FileLoaded } from '../commands/handler';
import { BaseHandler, type CamelCase, type MakeRequired, type SnakeCase } from '../common';
import type { ClientEvents } from '../events/hooks';
import { type GatewayDispatchPayload } from '../types';
import type { ClientEvent, ClientNameEvents, CustomEvents, CustomEventsKeys, EventContext } from './event';
export type EventValue = MakeRequired<ClientEvent, '__filePath'> & {
    fired?: boolean;
};
export type GatewayEvents = Uppercase<SnakeCase<keyof ClientEvents>>;
export type ResolveEventParams<T extends ClientNameEvents | CustomEventsKeys | GatewayEvents> = T extends CustomEventsKeys ? [...Parameters<CustomEvents[T]>, UsingClient] : T extends GatewayEvents ? EventContext<{
    data: {
        name: CamelCase<T>;
    };
}> : T extends ClientNameEvents ? EventContext<{
    data: {
        name: T;
    };
}> : never;
export type ResolveEventRunParams<T extends ClientNameEvents | CustomEventsKeys | GatewayEvents> = T extends CustomEventsKeys ? Parameters<CustomEvents[T]> : T extends GatewayEvents ? EventContext<{
    data: {
        name: CamelCase<T>;
    };
}> : T extends ClientNameEvents ? EventContext<{
    data: {
        name: T;
    };
}> : never;
export type EventValues = {
    [K in CustomEventsKeys | GatewayEvents]: Omit<EventValue, 'run'> & {
        run(...args: ResolveEventRunParams<K>): any;
    };
};
export declare class EventHandler extends BaseHandler {
    protected client: Client | WorkerClient;
    constructor(client: Client | WorkerClient);
    onFail: (event: GatewayEvents | CustomEventsKeys, err: unknown) => void;
    filter: (path: string) => boolean;
    values: Partial<EventValues>;
    discordEvents: ClientNameEvents[];
    set(events: ClientEvent[]): void;
    load(eventsDir: string): Promise<void>;
    execute(raw: GatewayDispatchPayload, client: Client<true> | WorkerClient<true>, shardId: number): Promise<void>;
    runEvent(name: GatewayEvents, client: Client | WorkerClient, packet: unknown, shardId: number, runCache?: boolean): Promise<void>;
    runCustom<T extends CustomEventsKeys>(name: T, ...args: ResolveEventRunParams<T>): Promise<void>;
    reload(name: GatewayEvents | CustomEventsKeys): Promise<any>;
    reloadAll(stopIfFail?: boolean): Promise<void>;
    onFile(file: FileLoaded<ClientEvent>): ClientEvent[] | undefined;
    callback: (file: ClientEvent) => ClientEvent | false;
}
