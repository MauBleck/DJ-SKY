import type { ComponentCallback, ComponentOnErrorCallback, ListenerOptions, ModalSubmitCallback } from '../builders/types';
import { LimitedCollection } from '../collection';
import { type UsingClient } from '../commands';
import type { FileLoaded } from '../commands/handler';
import { BaseHandler, type Logger, type OnFailCallback } from '../common';
import type { ComponentInteraction, ModalSubmitInteraction, StringSelectMenuInteraction } from '../structures';
import { ComponentCommand } from './componentcommand';
import type { ComponentContext } from './componentcontext';
import { ModalCommand } from './modalcommand';
import type { ModalContext } from './modalcontext';
type UserMatches = string | string[] | RegExp;
type COMPONENTS = {
    components: {
        match: MatchCallback;
        callback: ComponentCallback;
    }[];
    options?: ListenerOptions;
    messageId: string;
    channelId: string;
    guildId: string | undefined;
    idle?: NodeJS.Timeout;
    timeout?: NodeJS.Timeout;
    onError?: ComponentOnErrorCallback;
    __run: (customId: UserMatches, callback: ComponentCallback) => any;
};
export type MatchCallback = (str: string) => boolean;
export type CollectorInteraction = ComponentInteraction | StringSelectMenuInteraction;
export type ComponentCommands = ComponentCommand | ModalCommand;
export interface CreateComponentCollectorResult {
    run<T extends CollectorInteraction = CollectorInteraction>(customId: UserMatches, callback: ComponentCallback<T>): void;
    stop(reason?: string): void;
}
export declare class ComponentHandler extends BaseHandler {
    protected client: UsingClient;
    onFail: OnFailCallback;
    readonly values: Map<string, COMPONENTS>;
    readonly modals: LimitedCollection<string, ModalSubmitCallback>;
    readonly commands: ComponentCommands[];
    filter: (path: string) => boolean;
    constructor(logger: Logger, client: UsingClient);
    private createMatchCallback;
    createComponentCollector(messageId: string, channelId: string, guildId: string | undefined, options?: ListenerOptions, components?: COMPONENTS['components']): CreateComponentCollectorResult;
    onComponent(id: string, interaction: ComponentInteraction): Promise<any>;
    hasComponent(id: string, customId: string): boolean | undefined;
    resetTimeouts(id: string): void;
    hasModal(interaction: ModalSubmitInteraction): boolean;
    onModalSubmit(interaction: ModalSubmitInteraction): any;
    deleteValue(id: string, reason?: string): void;
    clearValue(id: string): COMPONENTS | undefined;
    stablishDefaults(component: ComponentCommands): void;
    set(instances: (new () => ComponentCommands)[]): void;
    load(componentsDir: string): Promise<void>;
    reload(path: string): Promise<any>;
    reloadAll(stopIfFail?: boolean): Promise<void>;
    execute(i: ComponentCommands, context: ComponentContext | ModalContext): Promise<any>;
    executeComponent(context: ComponentContext): Promise<void>;
    executeModal(context: ModalContext): Promise<void>;
    onFile(file: FileLoaded<new () => ComponentCommands>): (new () => ComponentCommands)[] | undefined;
    callback(file: {
        new (): ComponentCommands;
    }): ComponentCommands | false;
}
export {};
