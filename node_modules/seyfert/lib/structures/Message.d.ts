import { type AllChannels, Embed, type ReturnCache } from '..';
import type { ListenerOptions } from '../builders';
import { type GuildMemberStructure, type GuildStructure, type MessageStructure, type PollStructure, type UserStructure, type WebhookMessageStructure, type WebhookStructure } from '../client/transformers';
import type { UsingClient } from '../commands';
import { type ObjectToLower } from '../common';
import type { EmojiResolvable } from '../common/types/resolvables';
import type { MessageCreateBodyRequest, MessageUpdateBodyRequest } from '../common/types/write';
import type { TopLevelComponents } from '../components';
import type { APIChannelMention, APIEmbed, APIMessage, GatewayMessageCreateDispatchData } from '../types';
import type { MessageWebhookMethodEditParams, MessageWebhookMethodWriteParams } from './Webhook';
import { DiscordBase } from './extra/DiscordBase';
export type MessageData = APIMessage | GatewayMessageCreateDispatchData;
export interface BaseMessage extends DiscordBase, ObjectToLower<Omit<MessageData, 'timestamp' | 'author' | 'mentions' | 'components' | 'poll' | 'embeds'>> {
    timestamp?: number;
    guildId?: string;
    author: UserStructure;
    member?: GuildMemberStructure;
    components: TopLevelComponents[];
    poll?: PollStructure;
    mentions: {
        roles: string[];
        channels: APIChannelMention[];
        users: (GuildMemberStructure | UserStructure)[];
    };
}
export declare class BaseMessage extends DiscordBase {
    embeds: InMessageEmbed[];
    constructor(client: UsingClient, data: MessageData);
    get user(): UserStructure;
    createComponentCollector(options?: ListenerOptions): import("../components/handler").CreateComponentCollectorResult;
    get url(): `https://discord.com/channels/${string}/${string}/${string}`;
    guild(mode?: 'rest' | 'flow'): Promise<GuildStructure<'cached' | 'api'> | undefined>;
    guild(mode: 'cache'): ReturnCache<GuildStructure<'cached'> | undefined>;
    channel(mode?: 'rest' | 'flow'): Promise<AllChannels>;
    channel(mode: 'cache'): ReturnCache<AllChannels | undefined>;
    react(emoji: EmojiResolvable): Promise<void>;
    private patch;
}
export interface Message extends BaseMessage, ObjectToLower<Omit<MessageData, 'timestamp' | 'author' | 'mentions' | 'components' | 'poll' | 'embeds'>> {
}
export declare class Message extends BaseMessage {
    constructor(client: UsingClient, data: MessageData);
    fetch(force?: boolean): Promise<MessageStructure>;
    reply(body: Omit<MessageCreateBodyRequest, 'message_reference'>, fail?: boolean): Promise<MessageStructure>;
    edit(body: MessageUpdateBodyRequest): Promise<MessageStructure>;
    write(body: MessageCreateBodyRequest): Promise<MessageStructure>;
    delete(reason?: string): Promise<void>;
    crosspost(reason?: string): Promise<MessageStructure>;
}
export type EditMessageWebhook = Omit<MessageWebhookMethodEditParams, 'messageId'>['body'] & Pick<MessageWebhookMethodEditParams, 'query'>;
export type WriteMessageWebhook = MessageWebhookMethodWriteParams['body'] & Pick<MessageWebhookMethodWriteParams, 'query'>;
export declare class WebhookMessage extends BaseMessage {
    readonly webhookId: string;
    readonly webhookToken: string;
    constructor(client: UsingClient, data: MessageData, webhookId: string, webhookToken: string);
    fetchWebhook(): Promise<WebhookStructure>;
    fetch(): Promise<WebhookMessageStructure>;
    edit(body: EditMessageWebhook): Promise<WebhookMessageStructure>;
    write(body: WriteMessageWebhook): Promise<WebhookMessageStructure | null>;
    delete(reason?: string): Promise<never>;
}
export declare class InMessageEmbed {
    data: APIEmbed;
    constructor(data: APIEmbed);
    get title(): string | undefined;
    get type(): import("../types").EmbedType | undefined;
    get description(): string | undefined;
    get url(): string | undefined;
    get timestamp(): string | undefined;
    get color(): number | undefined;
    get footer(): {
        text: string;
        iconUrl?: string | undefined;
        proxyIconUrl?: string | undefined;
    } | undefined;
    get image(): {
        url: string;
        proxyUrl?: string | undefined;
        height?: number | undefined;
        width?: number | undefined;
    } | undefined;
    get thumbnail(): {
        url: string;
        proxyUrl?: string | undefined;
        height?: number | undefined;
        width?: number | undefined;
    } | undefined;
    get video(): {
        url?: string | undefined;
        proxyUrl?: string | undefined;
        height?: number | undefined;
        width?: number | undefined;
    } | undefined;
    get provider(): import("../types").APIEmbedProvider | undefined;
    get author(): {
        name: string;
        url?: string | undefined;
        iconUrl?: string | undefined;
        proxyIconUrl?: string | undefined;
    } | undefined;
    get fields(): import("../types").APIEmbedField[] | undefined;
    toBuilder(): Embed;
    toJSON(): {
        title?: string;
        type?: import("../types").EmbedType;
        description?: string;
        url?: string;
        timestamp?: string;
        color?: number;
        footer?: import("../types").APIEmbedFooter;
        image?: import("../types").APIEmbedImage;
        thumbnail?: import("../types").APIEmbedThumbnail;
        video?: import("../types").APIEmbedVideo;
        provider?: import("../types").APIEmbedProvider;
        author?: import("../types").APIEmbedAuthor;
        fields?: import("../types").APIEmbedField[];
    };
}
