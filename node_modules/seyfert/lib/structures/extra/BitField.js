"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitField = void 0;
class BitField {
    static None = 0n;
    Flags = {};
    bit = BitField.None;
    constructor(bitfields) {
        if (bitfields)
            this.bit = this.resolve(bitfields);
    }
    set bits(bits) {
        this.bit = this.resolve(bits);
    }
    get bits() {
        return this.bit;
    }
    has(bits) {
        const bitsResolved = bits.map(bit => this.resolve(bit));
        return bitsResolved.every(bit => (this.bits & bit) === bit);
    }
    missings(bits) {
        const bitsResolved = bits.map(bit => this.resolve(bit));
        return bitsResolved.filter(bit => (this.bits & bit) !== bit);
    }
    equals(other) {
        return this.bits === this.resolve(other);
    }
    keys(bits = [this.bits]) {
        const bitsResolved = bits.map(bit => this.resolve(bit));
        return Object.entries(this.Flags).reduce((acc, value) => {
            if (bitsResolved.some(bit => (bit & value[1]) === value[1])) {
                acc.push(value[0]);
                return acc;
            }
            return acc;
        }, []);
    }
    values(bits = [this.bits]) {
        const bitsResolved = bits.map(bit => this.resolve(bit));
        return Object.entries(this.Flags).reduce((acc, value) => {
            if (bitsResolved.some(bit => (bit & value[1]) === value[1])) {
                acc.push(value[1]);
                return acc;
            }
            return acc;
        }, []);
    }
    add(bits) {
        for (const bit of bits) {
            if (!bit)
                continue;
            this.bits |= this.resolve(bit);
        }
        return this.bits;
    }
    remove(bits) {
        for (const bit of bits) {
            this.bits &= ~this.resolve(bit);
        }
        return this.bits;
    }
    resolve(bits) {
        let bitsResult = 0n;
        for (const bit of Array.isArray(bits) ? bits : [bits]) {
            switch (typeof bit) {
                case 'string':
                    bitsResult |= this.resolve([this.Flags[bit]]);
                    break;
                case 'number':
                    bitsResult |= BigInt(bit);
                    break;
                case 'bigint':
                    bitsResult |= bit;
                    break;
                default:
                    throw new TypeError(`Cannot resolve permission: ${typeof bit === 'symbol' ? String(bit) : bit}`);
            }
        }
        return bitsResult;
    }
}
exports.BitField = BitField;
