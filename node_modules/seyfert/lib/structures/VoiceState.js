"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceState = void 0;
const transformers_1 = require("../client/transformers");
const Base_1 = require("./extra/Base");
class VoiceState extends Base_1.Base {
    withMember;
    constructor(client, data) {
        super(client);
        const { member, ...rest } = data;
        this.__patchThis(rest);
        if (member?.user && data.guild_id)
            this.withMember = transformers_1.Transformers.GuildMember(client, member, member.user, data.guild_id);
    }
    get isMuted() {
        return this.mute || this.selfMute;
    }
    async member(force) {
        return (this.withMember = await this.client.members.fetch(this.guildId, this.userId, force));
    }
    user(force) {
        return this.client.users.fetch(this.userId, force);
    }
    channel(mode = 'flow') {
        if (!this.channelId)
            return mode === 'cache' ? (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined) : Promise.resolve();
        switch (mode) {
            case 'cache':
                return (this.client.cache.channels?.get(this.channelId) ||
                    (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined));
            default:
                return this.client.channels.fetch(this.channelId, mode === 'rest');
        }
    }
    async setMute(mute = !this.mute, reason) {
        const member = await this.client.members.edit(this.guildId, this.userId, { mute }, reason);
        this.mute = mute;
        return member;
    }
    async setDeaf(deaf = !this.deaf, reason) {
        const member = await this.client.members.edit(this.guildId, this.userId, { deaf }, reason);
        this.deaf = deaf;
        return member;
    }
    async setSuppress(suppress = !this.suppress) {
        await this.client.voiceStates.setSuppress(this.guildId, suppress);
        this.suppress = suppress;
    }
    async requestSpeak(date = new Date()) {
        if (typeof date === 'string')
            date = new Date(date);
        if (Number.isNaN(date))
            return Promise.reject('Invalid date');
        date = date.toISOString();
        await this.client.voiceStates.requestSpeak(this.guildId, date);
        this.requestToSpeakTimestamp = date;
    }
    disconnect(reason) {
        return this.setChannel(null, reason);
    }
    async fetch(force = false) {
        const member = this.withMember ?? (await this.member(force));
        return this.client.members.voice(this.guildId, member.id, force);
    }
    async setChannel(channel_id, reason) {
        const member = await this.client.members.edit(this.guildId, this.userId, { channel_id }, reason);
        this.channelId = channel_id;
        return member;
    }
    guild(mode = 'flow') {
        switch (mode) {
            case 'cache':
                return (this.client.cache.guilds?.get(this.guildId) ||
                    (this.client.cache.adapter.isAsync ? Promise.resolve() : undefined));
            default:
                return this.client.guilds.fetch(this.guildId, mode === 'rest');
        }
    }
}
exports.VoiceState = VoiceState;
