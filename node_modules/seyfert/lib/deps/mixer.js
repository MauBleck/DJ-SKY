"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mix = void 0;
exports.copyProperties = copyProperties;
exports.Mixin = Mixin;
const IgnoredProps = ['constructor', 'prototype', 'name'];
function copyProperties(target, source) {
    const keys = Reflect.ownKeys(source);
    for (const key of keys) {
        if (IgnoredProps.includes(key))
            continue;
        if (key in target)
            continue;
        const descriptor = Object.getOwnPropertyDescriptor(source, key);
        if (descriptor) {
            Object.defineProperty(target, key, descriptor);
        }
    }
}
function Mixin(...mixins) {
    const Base = mixins[0];
    class MixedClass extends Base {
        constructor(...args) {
            super(...args);
            for (const mixin of mixins.slice(1)) {
                // @ts-expect-error
                const mixinInstance = new mixin(...args);
                copyProperties(this, mixinInstance);
                let proto = Object.getPrototypeOf(mixinInstance);
                while (proto && proto !== Object.prototype) {
                    copyProperties(this, proto);
                    proto = Object.getPrototypeOf(proto);
                }
            }
        }
    }
    return MixedClass;
}
const mix = (...ingredients) => (decoratedClass) => {
    ingredients.unshift(decoratedClass);
    const mixedClass = Mixin(...ingredients);
    Object.defineProperty(mixedClass, 'name', {
        value: decoratedClass.name,
        writable: false,
    });
    return mixedClass;
};
exports.mix = mix;
