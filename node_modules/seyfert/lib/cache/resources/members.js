"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Members = void 0;
const transformers_1 = require("../../client/transformers");
const common_1 = require("../../common");
const guild_based_1 = require("./default/guild-based");
class Members extends guild_based_1.GuildBasedResource {
    namespace = 'member';
    //@ts-expect-error
    filter(data, id, guild_id, from) {
        return true;
    }
    parse(data, key, guild_id) {
        const { user, ...rest } = super.parse(data, data.user?.id ?? key, guild_id);
        return rest;
    }
    get(id, guild) {
        return (0, common_1.fakePromise)(super.get(id, guild)).then(rawMember => (0, common_1.fakePromise)(this.client.cache.users?.raw(id)).then(user => rawMember && user ? transformers_1.Transformers.GuildMember(this.client, rawMember, user, guild) : undefined));
    }
    raw(id, guild) {
        return (0, common_1.fakePromise)(super.get(id, guild)).then(rawMember => {
            return (0, common_1.fakePromise)(this.client.cache.users?.raw(id)).then(user => rawMember && user
                ? {
                    ...rawMember,
                    user,
                }
                : undefined);
        });
    }
    bulk(ids, guild) {
        return (0, common_1.fakePromise)(super.bulk(ids, guild)).then(members => (0, common_1.fakePromise)(this.client.cache.users?.bulkRaw(ids)).then(users => {
            if (!users)
                return [];
            let usersRecord = {};
            for (const user of users) {
                usersRecord[user.id] = user;
            }
            const result = members
                .map(rawMember => {
                const user = usersRecord[rawMember.id];
                return user ? transformers_1.Transformers.GuildMember(this.client, rawMember, user, guild) : undefined;
            })
                .filter(x => x !== undefined);
            usersRecord = null;
            return result;
        }));
    }
    bulkRaw(ids, guild) {
        return super.bulk(ids, guild);
    }
    values(guild) {
        return (0, common_1.fakePromise)(super.values(guild)).then(members => (0, common_1.fakePromise)(this.client.cache.users?.bulkRaw(members.map(member => member.id))).then(users => {
            if (!users)
                return [];
            let usersRecord = {};
            for (const user of users) {
                usersRecord[user.id] = user;
            }
            const result = members
                .map(rawMember => {
                const user = usersRecord[rawMember.id];
                return user ? transformers_1.Transformers.GuildMember(this.client, rawMember, user, rawMember.guild_id) : undefined;
            })
                .filter(x => x !== undefined);
            usersRecord = null;
            return result;
        }));
    }
    valuesRaw(guild) {
        return super.values(guild);
    }
    async set(from, __keys, guild, data) {
        const keys = Array.isArray(__keys) ? __keys : [[__keys, data]];
        const bulkData = [];
        for (const [id, value] of keys) {
            if (value.user) {
                bulkData.push([from, 'members', value, id, guild]);
                bulkData.push([from, 'users', value.user, id]);
            }
        }
        await this.cache.bulkSet(bulkData);
    }
}
exports.Members = Members;
