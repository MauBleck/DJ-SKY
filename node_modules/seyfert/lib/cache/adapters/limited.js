"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitedMemoryAdapter = void 0;
const __1 = require("../..");
const common_1 = require("../../common");
class LimitedMemoryAdapter {
    isAsync = false;
    storage = new Map();
    relationships = new Map();
    options;
    constructor(options) {
        this.options = (0, common_1.MergeOptions)({
            default: {
                expire: undefined,
                limit: Number.POSITIVE_INFINITY,
            },
            encode(data) {
                return data;
            },
            decode(data) {
                return data;
            },
        }, options);
    }
    start() {
        //
    }
    scan(query, keys = false) {
        const sq = query.split('.');
        const isWildcard = sq.map(segment => segment === '*');
        return [...this.storage.values()].flatMap(storageEntry => Array.from(storageEntry.entries())
            .filter(([key]) => key.split('.').every((value, i) => isWildcard[i] || sq[i] === value))
            .map(([key, value]) => (keys ? key : this.options.decode(value.value))));
    }
    bulkGet(keys) {
        const storageArray = Array.from(this.storage.values());
        const keySet = new Set(keys);
        return storageArray.flatMap(storageEntry => {
            const entries = Array.from(storageEntry.entries());
            return entries.filter(([key]) => keySet.has(key)).map(([, value]) => this.options.decode(value.value));
        });
    }
    get(key) {
        for (const storageEntry of this.storage.values()) {
            if (storageEntry.has(key)) {
                const data = storageEntry.get(key);
                return data ? this.options.decode(data) : null;
            }
        }
        return null;
    }
    __set(key, data) {
        const __guildId = Array.isArray(data) ? data[0].guild_id : data.guild_id;
        const namespace = `${key.split('.')[0]}${__guildId ? `.${__guildId}` : ''}`;
        const self = this;
        if (!this.storage.has(namespace)) {
            this.storage.set(namespace, new __1.LimitedCollection({
                expire: this.options[key.split('.')[0]]
                    ?.expire ?? this.options.default.expire,
                limit: this.options[key.split('.')[0]]
                    ?.limit ?? this.options.default.limit,
                resetOnDemand: true,
                onDelete(k) {
                    const relationshipNamespace = key.split('.')[0];
                    const existsRelation = self.relationships.has(relationshipNamespace);
                    if (existsRelation) {
                        switch (relationshipNamespace) {
                            case 'ban':
                            case 'member':
                            case 'voice_state':
                                {
                                    const split = k.split('.');
                                    self.removeToRelationship(`${namespace}.${split[1]}`, split[2]);
                                }
                                break;
                            case 'channel':
                            case 'emoji':
                            case 'presence':
                            case 'role':
                            case 'stage_instance':
                            case 'sticker':
                            case 'overwrite':
                            case 'message':
                                self.removeToRelationship(namespace, k.split('.')[1]);
                                break;
                            // case 'guild':
                            // case 'user':
                            default:
                                self.removeToRelationship(namespace, k.split('.')[1]);
                                break;
                        }
                    }
                },
            }));
        }
        this.storage.get(namespace).set(key, this.options.encode(data));
    }
    bulkSet(keys) {
        for (const [key, value] of keys) {
            this.__set(key, value);
        }
    }
    set(keys, data) {
        this.__set(keys, data);
    }
    bulkPatch(keys) {
        for (const [key, value] of keys) {
            const oldData = this.get(key);
            this.__set(key, Array.isArray(value) ? value : { ...(oldData ?? {}), ...value });
        }
    }
    patch(keys, data) {
        const oldData = this.get(keys);
        this.__set(keys, Array.isArray(data) ? data : { ...(oldData ?? {}), ...data });
    }
    values(to) {
        const array = [];
        const data = this.keys(to);
        for (const key of data) {
            const content = this.get(key);
            if (content) {
                array.push(content);
            }
        }
        return array;
    }
    keys(to) {
        return this.getToRelationship(to).map(id => `${to}.${id}`);
    }
    count(to) {
        return this.getToRelationship(to).length;
    }
    bulkRemove(keys) {
        for (const i of keys) {
            this.remove(i);
        }
    }
    remove(key) {
        const keySplit = key.split('.');
        const parentNamespace = keySplit.at(0);
        switch (parentNamespace) {
            case 'ban':
            case 'member':
            case 'voice_state':
                {
                    this.storage
                        .get(`${parentNamespace}.${keySplit.at(1)}`)
                        ?.delete(`${parentNamespace}.${keySplit.at(1)}.${keySplit.at(2)}`);
                }
                break;
            case 'channel':
            case 'emoji':
            case 'presence':
            case 'role':
            case 'stage_instance':
            case 'sticker':
            case 'overwrite':
            case 'message':
                for (const keyStorage of this.storage.keys()) {
                    if (keyStorage.startsWith(parentNamespace)) {
                        const storage = this.storage.get(keyStorage);
                        if (storage.has(key)) {
                            storage.delete(key);
                            break;
                        }
                    }
                }
                break;
            // case 'user':
            // case 'guild':
            default:
                this.storage.get(parentNamespace)?.delete(`${parentNamespace}.${keySplit.at(1)}`);
                break;
        }
    }
    flush() {
        this.storage.clear();
        this.relationships.clear();
    }
    contains(to, keys) {
        return this.getToRelationship(to).includes(keys);
    }
    getToRelationship(to) {
        const key = to.split('.')[0];
        if (!this.relationships.has(key))
            this.relationships.set(key, new Map());
        const relation = this.relationships.get(key);
        const subrelationKey = to.split('.')[1] ?? '*';
        if (!relation.has(subrelationKey)) {
            relation.set(subrelationKey, []);
        }
        return relation.get(subrelationKey);
    }
    bulkAddToRelationShip(data) {
        for (const i in data) {
            this.addToRelationship(i, data[i]);
        }
    }
    addToRelationship(to, keys) {
        const key = to.split('.')[0];
        if (!this.relationships.has(key)) {
            this.relationships.set(key, new Map());
        }
        const data = this.getToRelationship(to);
        for (const key of Array.isArray(keys) ? keys : [keys]) {
            if (!data.includes(key)) {
                data.push(key);
            }
        }
    }
    removeToRelationship(to, keys) {
        const data = this.getToRelationship(to);
        if (data) {
            for (const key of Array.isArray(keys) ? keys : [keys]) {
                const idx = data.indexOf(key);
                if (idx !== -1) {
                    data.splice(idx, 1);
                }
            }
        }
    }
    removeRelationship(to) {
        for (const i of Array.isArray(to) ? to : [to]) {
            this.relationships.delete(i);
        }
    }
}
exports.LimitedMemoryAdapter = LimitedMemoryAdapter;
