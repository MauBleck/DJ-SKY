"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryAdapter = void 0;
class MemoryAdapter {
    options;
    isAsync = false;
    storage = new Map();
    relationships = new Map();
    constructor(options = {
        encode(data) {
            return data;
        },
        decode(data) {
            return data;
        },
    }) {
        this.options = options;
    }
    start() {
        //
    }
    scan(query, keys = false) {
        const values = [];
        const sq = query.split('.');
        for (const [key, value] of this.storage.entries()) {
            if (key.split('.').every((value, i) => (sq[i] === '*' ? !!value : sq[i] === value))) {
                values.push(keys ? key : this.options.decode(value));
            }
        }
        return values;
    }
    bulkGet(keys) {
        return keys
            .map(x => {
            const data = this.storage.get(x);
            return data ? this.options.decode(data) : null;
        })
            .filter(x => x);
    }
    get(keys) {
        const data = this.storage.get(keys);
        return data ? this.options.decode(data) : null;
    }
    bulkSet(keys) {
        for (const [key, value] of keys) {
            this.storage.set(key, this.options.encode(value));
        }
    }
    set(key, data) {
        this.storage.set(key, this.options.encode(data));
    }
    bulkPatch(keys) {
        for (const [key, value] of keys) {
            const oldData = this.get(key);
            this.storage.set(key, Array.isArray(value) ? this.options.encode(value) : this.options.encode({ ...(oldData ?? {}), ...value }));
        }
    }
    patch(keys, data) {
        const oldData = this.get(keys);
        this.storage.set(keys, Array.isArray(data) ? this.options.encode(data) : this.options.encode({ ...(oldData ?? {}), ...data }));
    }
    values(to) {
        const array = [];
        const data = this.keys(to);
        for (const key of data) {
            const content = this.get(key);
            if (content) {
                array.push(content);
            }
        }
        return array;
    }
    keys(to) {
        return this.getToRelationship(to).map(id => `${to}.${id}`);
    }
    count(to) {
        return this.getToRelationship(to).length;
    }
    bulkRemove(keys) {
        for (const i of keys) {
            this.storage.delete(i);
        }
    }
    remove(key) {
        this.storage.delete(key);
    }
    flush() {
        this.storage.clear();
        this.relationships.clear();
    }
    contains(to, keys) {
        return this.getToRelationship(to).includes(keys);
    }
    getToRelationship(to) {
        return this.relationships.get(to) || [];
    }
    bulkAddToRelationShip(data) {
        for (const i in data) {
            this.addToRelationship(i, data[i]);
        }
    }
    addToRelationship(to, keys) {
        if (!this.relationships.has(to)) {
            this.relationships.set(to, []);
        }
        const data = this.getToRelationship(to);
        for (const key of Array.isArray(keys) ? keys : [keys]) {
            if (!data.includes(key)) {
                data.push(key);
            }
        }
    }
    removeToRelationship(to, keys) {
        const data = this.getToRelationship(to);
        if (data) {
            for (const key of Array.isArray(keys) ? keys : [keys]) {
                const idx = data.indexOf(key);
                if (idx !== -1) {
                    data.splice(idx, 1);
                }
            }
        }
    }
    removeRelationship(to) {
        for (const i of Array.isArray(to) ? to : [to]) {
            this.relationships.delete(i);
        }
    }
}
exports.MemoryAdapter = MemoryAdapter;
