"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CooldownManager = void 0;
const cache_1 = require("seyfert/lib/cache");
const common_1 = require("seyfert/lib/common");
const resource_1 = require("./resource");
class CooldownManager {
    client;
    resource;
    constructor(client) {
        this.client = client;
        this.resource = new resource_1.CooldownResource(client.cache, client);
    }
    getCommandData(name, guildId) {
        if (!this.client.commands?.values?.length)
            return;
        for (const command of this.client.commands.values) {
            if (!('cooldown' in command))
                continue;
            if (guildId && !command.guildId?.includes(guildId))
                continue;
            if (command.name === name)
                return [command.name, command.cooldown];
            if ('options' in command) {
                const option = command.options?.find((x) => x.name === name);
                if (option) {
                    return [option.name, option.cooldown ?? command.cooldown];
                }
            }
        }
        return undefined;
    }
    has(options) {
        const [resolve, data] = this.getCommandData(options.name, options.guildId) ?? [];
        if (!(data && resolve))
            return false;
        return (0, common_1.fakePromise)(this.resource.get(`${resolve}:${data.type}:${options.target}`)).then(cooldown => {
            if ((options.tokens ?? 1) > data.uses[options.use ?? 'default'])
                return true;
            if (!cooldown) {
                return (0, common_1.fakePromise)(this.set({
                    name: resolve,
                    target: options.target,
                    type: data.type,
                    interval: data.interval,
                    remaining: data.uses[options.use ?? 'default'],
                })).then(() => false);
            }
            const remaining = Math.max(cooldown.remaining - (options.tokens ?? 1), 0);
            return remaining === 0;
        });
    }
    set(options) {
        return this.resource.set(cache_1.CacheFrom.Gateway, `${options.name}:${options.type}:${options.target}`, {
            interval: options.interval,
            remaining: options.remaining,
            lastDrip: options.lastDrip,
        });
    }
    context(context, use, guildId) {
        if (!('command' in context))
            return true;
        if (!('name' in context.command))
            return true;
        const cd = context.command.cooldown;
        if (!cd)
            return true;
        let target;
        switch (cd.type) {
            case 'user':
                target = context.author.id;
                break;
            case 'guild':
                target = context.guildId;
                break;
            case 'channel':
                target = context.channelId;
                break;
        }
        target ??= context.author.id;
        return this.use({ name: context.command.name, target, use, guildId });
    }
    /**
     * Use a cooldown
     * @returns The remaining cooldown in seconds or true if successful
     */
    use(options) {
        const [resolve, data] = this.getCommandData(options.name, options.guildId) ?? [];
        if (!(data && resolve))
            return true;
        return (0, common_1.fakePromise)(this.resource.get(`${resolve}:${data.type}:${options.target}`)).then(cooldown => {
            if (!cooldown) {
                return (0, common_1.fakePromise)(this.set({
                    name: resolve,
                    target: options.target,
                    type: data.type,
                    interval: data.interval,
                    remaining: data.uses[options.use ?? 'default'] - 1,
                })).then(() => true);
            }
            return (0, common_1.fakePromise)(this.drip({
                name: resolve,
                props: data,
                data: cooldown,
                target: options.target,
                use: options.use,
            })).then(drip => {
                return typeof drip === 'number' ? data.interval - drip : true;
            });
        });
    }
    /**
     * Drip the cooldown
     * @returns The cooldown was processed
     */
    drip(options) {
        const now = Date.now();
        const deltaMS = now - options.data.lastDrip;
        if (deltaMS >= options.props.interval) {
            return (0, common_1.fakePromise)(this.resource.patch(cache_1.CacheFrom.Gateway, `${options.name}:${options.props.type}:${options.target}`, {
                lastDrip: now,
                remaining: options.props.uses[options.use ?? 'default'] - 1,
            })).then(() => true);
        }
        if (options.data.remaining - 1 < 0) {
            return deltaMS;
        }
        return (0, common_1.fakePromise)(this.resource.patch(cache_1.CacheFrom.Gateway, `${options.name}:${options.props.type}:${options.target}`, {
            remaining: options.data.remaining - 1,
        })).then(() => true);
    }
    /**
     * Refill the cooldown
     * @param name - The name of the command
     * @param target - The target of the cooldown
     * @returns Whether the cooldown was refilled
     */
    refill(name, target, use = 'default') {
        const [resolve, data] = this.getCommandData(name) ?? [];
        if (!(data && resolve))
            return false;
        return (0, common_1.fakePromise)(this.resource.patch(cache_1.CacheFrom.Gateway, `${resolve}:${data.type}:${target}`, { remaining: data.uses[use] })).then(() => true);
    }
}
exports.CooldownManager = CooldownManager;
